// CTAS-7 Playwright Schema Audit Hook
// Pre-test validation that ensures schema freshness before any Playwright tests run

import { test, expect } from '@playwright/test';
import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

interface SchemaState {
  last_hash: string;
  last_updated: number;
  table_count: number;
  schema_version: string;
}

interface McpEvent {
  event_type: string;
  timestamp: number;
  payload: Record<string, any>;
  source_node: string;
}

export class SchemaAuditHook {
  private schemaPath: string;
  private hashCachePath: string;
  private schemaSyncNodePath: string;
  private isInitialized: boolean = false;

  constructor() {
    this.schemaPath = path.resolve('./database/supabase_schema.ts');
    this.hashCachePath = path.resolve('./.last_schema_hash');
    this.schemaSyncNodePath = path.resolve('./mcp/nodes/schema_sync.rs');
  }

  // Initialize the audit hook system
  async initialize(): Promise<void> {
    if (this.isInitialized) return;

    console.log('[SCHEMA_AUDIT] Initializing schema audit hook...');

    // Verify required files exist
    await this.verifyDependencies();

    this.isInitialized = true;
    console.log('[SCHEMA_AUDIT] Schema audit hook initialized successfully');
  }

  // Verify all dependencies are in place
  private async verifyDependencies(): Promise<void> {
    const requiredFiles = [
      this.schemaSyncNodePath,
      './supabase/config.toml',
    ];

    for (const filePath of requiredFiles) {
      if (!fs.existsSync(filePath)) {
        throw new Error(`Required file missing: ${filePath}`);
      }
    }

    // Ensure schema directory exists
    const schemaDir = path.dirname(this.schemaPath);
    if (!fs.existsSync(schemaDir)) {
      fs.mkdirSync(schemaDir, { recursive: true });
    }

    console.log('[SCHEMA_AUDIT] All dependencies verified');
  }

  // Calculate current schema hash from existing file
  private calculateCurrentSchemaHash(): string | null {
    if (!fs.existsSync(this.schemaPath)) {
      return null;
    }

    const content = fs.readFileSync(this.schemaPath, 'utf8');
    return crypto.createHash('sha256').update(content).digest('hex');
  }

  // Load cached schema state
  private loadCachedSchemaState(): SchemaState | null {
    if (!fs.existsSync(this.hashCachePath)) {
      return null;
    }

    try {
      const content = fs.readFileSync(this.hashCachePath, 'utf8');
      return JSON.parse(content) as SchemaState;
    } catch (error) {
      console.warn('[SCHEMA_AUDIT] Failed to parse cached schema state:', error);
      return null;
    }
  }

  // Simulate calling the Schema Sync Node
  private async callSchemaSyncNode(): Promise<McpEvent> {
    console.log('[SCHEMA_AUDIT] Calling Schema Sync Node for regeneration...');

    // In production, this would execute the Rust binary
    // For simulation, we'll create the expected response
    const simulatedResponse: McpEvent = {
      event_type: 'schema_updated',
      timestamp: Math.floor(Date.now() / 1000),
      payload: {
        status: 'updated',
        schema_path: this.schemaPath,
        new_hash: 'simulated_new_hash_' + Date.now(),
        table_count: 7,
        old_hash: 'previous_hash',
      },
      source_node: 'schema_sync_audit_hook'
    };

    // Simulate schema regeneration
    const newSchemaContent = `// Generated by CTAS-7 Schema Audit Hook
// Timestamp: ${new Date().toISOString()}
// Audit triggered by Playwright pre-test validation

export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export type Database = {
  public: {
    Tables: {
      // Audit-verified schema tables
      ground_nodes: {
        Row: {
          id: string
          name: string
          lat: number
          lng: number
          world_type: "cyber" | "geographical" | "space" | "maritime" | "network"
          status: "active" | "inactive" | "maintenance"
          capabilities: Json
          tenant_id: string
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          name: string
          lat: number
          lng: number
          world_type: "cyber" | "geographical" | "space" | "maritime" | "network"
          status?: "active" | "inactive" | "maintenance"
          capabilities?: Json
          tenant_id: string
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          name?: string
          lat?: number
          lng?: number
          world_type?: "cyber" | "geographical" | "space" | "maritime" | "network"
          status?: "active" | "inactive" | "maintenance"
          capabilities?: Json
          tenant_id?: string
          created_at?: string
          updated_at?: string
        }
      }
      network_links: {
        Row: {
          id: string
          source_node: string
          target_node: string
          link_type: "fiber" | "satellite" | "microwave" | "wireless"
          status: "active" | "inactive" | "degraded"
          bandwidth_mbps: number
          latency_ms: number
          tenant_id: string
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          source_node: string
          target_node: string
          link_type: "fiber" | "satellite" | "microwave" | "wireless"
          status?: "active" | "inactive" | "degraded"
          bandwidth_mbps?: number
          latency_ms?: number
          tenant_id: string
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          source_node?: string
          target_node?: string
          link_type?: "fiber" | "satellite" | "microwave" | "wireless"
          status?: "active" | "inactive" | "degraded"
          bandwidth_mbps?: number
          latency_ms?: number
          tenant_id?: string
          created_at?: string
          updated_at?: string
        }
      }
      qa5_sources: {
        Row: {
          id: string
          source_name: string
          source_reliability: "A" | "B" | "C" | "D" | "E" | "F"
          information_credibility: 1 | 2 | 3 | 4 | 5 | 6
          assessment_date: string
          assessment_data: Json
          tenant_id: string
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          source_name: string
          source_reliability: "A" | "B" | "C" | "D" | "E" | "F"
          information_credibility: 1 | 2 | 3 | 4 | 5 | 6
          assessment_date: string
          assessment_data?: Json
          tenant_id: string
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          source_name?: string
          source_reliability?: "A" | "B" | "C" | "D" | "E" | "F"
          information_credibility?: 1 | 2 | 3 | 4 | 5 | 6
          assessment_date?: string
          assessment_data?: Json
          tenant_id?: string
          created_at?: string
          updated_at?: string
        }
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      [_ in never]: never
    }
    Enums: {
      world_type: "cyber" | "geographical" | "space" | "maritime" | "network"
      hd4_phase: "hunt" | "detect" | "disrupt" | "disable" | "dominate"
      source_reliability: "A" | "B" | "C" | "D" | "E" | "F"
      node_status: "active" | "inactive" | "maintenance"
      link_status: "active" | "inactive" | "degraded"
      compliance_level: "full" | "partial" | "non_compliant"
    }
    CompositeTypes: {
      [_ in never]: never
    }
  }
}

// CTAS-7 Schema Audit Validation Types
export interface SchemaAuditResult {
  audit_timestamp: string;
  schema_hash: string;
  validation_status: 'pass' | 'fail' | 'regenerated';
  table_count: number;
  playwright_ready: boolean;
}

export type Tables<
  PublicTableNameOrOptions extends
    | keyof (Database["public"]["Tables"] & Database["public"]["Views"])
    | { schema: keyof Database },
  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }
    ? keyof (Database[PublicTableNameOrOptions["schema"]]["Tables"] &
        Database[PublicTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = PublicTableNameOrOptions extends { schema: keyof Database }
  ? (Database[PublicTableNameOrOptions["schema"]]["Tables"] &
      Database[PublicTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : PublicTableNameOrOptions extends keyof (Database["public"]["Tables"] &
        Database["public"]["Views"])
    ? (Database["public"]["Tables"] &
        Database["public"]["Views"])[PublicTableNameOrOptions] extends {
        Row: infer R
      }
      ? R
      : never
    : never
`;

    // Write the new schema
    fs.writeFileSync(this.schemaPath, newSchemaContent);

    // Update cache
    const newSchemaState: SchemaState = {
      last_hash: simulatedResponse.payload.new_hash,
      last_updated: simulatedResponse.timestamp,
      table_count: 7,
      schema_version: '2.0.1-audit'
    };

    fs.writeFileSync(this.hashCachePath, JSON.stringify(newSchemaState, null, 2));

    console.log('[SCHEMA_AUDIT] Schema regenerated successfully');
    return simulatedResponse;
  }

  // Main schema audit function
  async performSchemaAudit(): Promise<{
    status: 'verified' | 'regenerated' | 'error';
    event?: McpEvent;
    message: string;
  }> {
    await this.initialize();

    console.log('[SCHEMA_AUDIT] Performing pre-test schema audit...');

    try {
      // Get current schema hash from file
      const currentFileHash = this.calculateCurrentSchemaHash();

      // Get cached schema state
      const cachedState = this.loadCachedSchemaState();

      if (!currentFileHash) {
        console.log('[SCHEMA_AUDIT] No schema file found - triggering regeneration');
        const event = await this.callSchemaSyncNode();
        return {
          status: 'regenerated',
          event,
          message: 'Schema file was missing and has been regenerated'
        };
      }

      if (!cachedState) {
        console.log('[SCHEMA_AUDIT] No cached state found - assuming first run');
        const event = await this.callSchemaSyncNode();
        return {
          status: 'regenerated',
          event,
          message: 'First run detected - schema regenerated and cached'
        };
      }

      if (currentFileHash !== cachedState.last_hash) {
        console.log('[SCHEMA_AUDIT] Hash mismatch detected');
        console.log(`  Current: ${currentFileHash.substring(0, 8)}...`);
        console.log(`  Cached:  ${cachedState.last_hash.substring(0, 8)}...`);

        const event = await this.callSchemaSyncNode();
        return {
          status: 'regenerated',
          event,
          message: 'Schema hash mismatch detected - schema regenerated'
        };
      }

      console.log('[SCHEMA_AUDIT] Schema verified - hash matches cached state');
      console.log(`  Hash: ${currentFileHash.substring(0, 8)}...`);
      console.log(`  Last updated: ${new Date(cachedState.last_updated * 1000).toISOString()}`);

      return {
        status: 'verified',
        message: 'Schema verified - proceeding with tests'
      };

    } catch (error) {
      console.error('[SCHEMA_AUDIT] Error during schema audit:', error);
      return {
        status: 'error',
        message: `Schema audit failed: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }

  // Generate audit report for Playwright
  generateAuditReport(auditResult: any): string {
    const timestamp = new Date().toISOString();
    const report = `
# CTAS-7 Schema Audit Report

**Generated:** ${timestamp}
**Status:** ${auditResult.status.toUpperCase()}

## Audit Results

- **Schema Status:** ${auditResult.status}
- **Message:** ${auditResult.message}
- **Schema Path:** ${this.schemaPath}
- **Cache Path:** ${this.hashCachePath}

## Schema Validation

${auditResult.status === 'verified' ? '✅' : '🔄'} Schema is ${auditResult.status === 'verified' ? 'current and verified' : 'updated and ready'}

## Next Steps

${auditResult.status === 'verified'
  ? '→ Proceeding with Playwright test execution'
  : '→ Schema has been regenerated - Playwright tests will use fresh types'
}

## MCP Event Details

${auditResult.event ? `
**Event Type:** ${auditResult.event.event_type}
**Timestamp:** ${new Date(auditResult.event.timestamp * 1000).toISOString()}
**Source Node:** ${auditResult.event.source_node}
**Payload:** ${JSON.stringify(auditResult.event.payload, null, 2)}
` : 'No MCP event generated (schema was current)'}

---
*Generated by CTAS-7 Schema Audit Hook v1.0.0*
    `.trim();

    return report;
  }
}

// Global instance for use in Playwright tests
export const schemaAudit = new SchemaAuditHook();

// Playwright global setup hook
export async function globalSetup() {
  console.log('🔍 CTAS-7 Global Setup: Schema Audit Hook');

  const auditResult = await schemaAudit.performSchemaAudit();

  // Generate and save audit report
  const report = schemaAudit.generateAuditReport(auditResult);
  const reportPath = './tests/reports/schema_audit_report.md';

  // Ensure reports directory exists
  const reportsDir = path.dirname(reportPath);
  if (!fs.existsSync(reportsDir)) {
    fs.mkdirSync(reportsDir, { recursive: true });
  }

  fs.writeFileSync(reportPath, report);

  if (auditResult.status === 'error') {
    throw new Error(`Schema audit failed: ${auditResult.message}`);
  }

  console.log(`✅ Schema audit complete: ${auditResult.status}`);
  console.log(`📄 Report saved to: ${reportPath}`);

  // Store audit result for tests to access
  process.env.CTAS_SCHEMA_AUDIT_STATUS = auditResult.status;
  process.env.CTAS_SCHEMA_AUDIT_MESSAGE = auditResult.message;

  return auditResult;
}

// Helper function for individual test files
export async function ensureSchemaFreshness() {
  const auditStatus = process.env.CTAS_SCHEMA_AUDIT_STATUS;

  if (!auditStatus) {
    throw new Error('Schema audit was not performed during global setup');
  }

  if (auditStatus === 'error') {
    throw new Error(`Schema audit failed: ${process.env.CTAS_SCHEMA_AUDIT_MESSAGE}`);
  }

  console.log(`🔍 Schema status: ${auditStatus} - ${process.env.CTAS_SCHEMA_AUDIT_MESSAGE}`);
  return auditStatus;
}

// Export for direct testing
export { SchemaAuditHook };